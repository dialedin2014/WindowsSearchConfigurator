# Implementation Plan: Windows Search Configurator

**Branch**: `001-windows-search-configurator` | **Date**: 2025-10-22 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-windows-search-configurator/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

The Windows Search Configurator is a C# console application that enables system administrators to manage Windows Search index rules. The application provides comprehensive control over indexed locations, file type filters, subfolder exclusions, and indexing depth settings (Properties only vs Properties and Contents). It supports both interactive and command-line modes, includes JSON-based configuration import/export, maintains audit logs, and follows least-privilege principles (read operations for standard users, write operations require admin privileges). The application interfaces with Windows Search through COM/WMI/Registry APIs to provide full CRUD operations on index rules with comprehensive error handling and user confirmations for destructive actions.

## Technical Context

**Language/Version**: C# / .NET 8.0 (LTS) - targeting Windows 10/11 and Windows Server 2016+  
**Primary Dependencies**: 
- System.Management (WMI interop)
- Microsoft.Win32 (Registry access)
- System.Text.Json (JSON serialization for config files)
- System.CommandLine (CLI argument parsing)
- No third-party packages beyond standard Microsoft libraries (per FR-019)

**Storage**: 
- Windows Registry (reading/writing Windows Search configuration)
- JSON configuration files (import/export functionality)
- Text log files (audit trail in application directory or user profile)

**Testing**: 
- NUnit (unit testing framework)
- Moq (mocking Windows APIs for unit tests)
- FluentAssertions (assertion library)
- Integration tests requiring Windows Search service

**Target Platform**: Windows 10 (1809+), Windows 11, Windows Server 2016+  
**Project Type**: Single console application (CLI)  
**Performance Goals**: 
- View index rules: <5 seconds (SC-001)
- Batch operations: ≥50 rules in 30 seconds (SC-009)
- Extension search: <3 seconds (SC-011)

**Constraints**: 
- No external dependencies beyond Windows components (FR-019)
- Must handle paths up to 260 characters (SC-006)
- Admin elevation required for modifications only (FR-005)
- Must work without installation/deployment

**Scale/Scope**: 
- Single console application
- ~10-15 command implementations
- Support 50+ rules in batch operations
- Handle thousands of file extensions efficiently

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Automated Testing ✅ PASS
- **Requirement**: All production code MUST have automated tests
- **Compliance**: 
  - Unit tests planned for all business logic and command handlers
  - Integration tests for Windows Search API interactions
  - Contract tests for public CLI interfaces
  - Test-first approach for critical paths (privilege checking, path validation, API calls)
- **Status**: COMPLIANT - Testing strategy defined

### II. Windows API Safety ✅ PASS
- **Requirement**: All Windows Search API calls MUST include proper error handling
- **Compliance**:
  - All COM/WMI/Registry calls wrapped in try-catch with specific error handling
  - Input validation before API calls (FR-004, FR-010)
  - Clear error messages with actionable guidance (FR-007, SC-004)
  - Windows version compatibility documented in assumptions
- **Status**: COMPLIANT - Error handling strategy defined

### III. User Configuration Control ✅ PASS
- **Requirement**: Users MUST maintain full control over search indexing configuration
- **Compliance**:
  - Explicit confirmation prompts for destructive operations (FR-006)
  - Preview of changes before applying (acceptance scenarios)
  - Export/import supports rollback capability (FR-011, FR-012)
  - No silent modifications - all changes user-initiated
- **Status**: COMPLIANT - User control mechanisms defined

### IV. Clear Interface Design ✅ PASS
- **Requirement**: All interfaces MUST be clear and discoverable
- **Compliance**:
  - Self-documenting command names (list, add, remove, modify, export, import)
  - Help command with usage examples (FR-014)
  - Clear error messages with suggested resolutions (FR-007, SC-004)
  - Standard CLI conventions using System.CommandLine
- **Status**: COMPLIANT - Interface design principles defined

### V. Documentation and Maintainability ✅ PASS
- **Requirement**: Code MUST be documented and maintainable
- **Compliance**:
  - quickstart.md planned for setup and usage
  - Public APIs will have XML documentation comments
  - Complex Windows API interactions documented with rationale
  - Architecture decisions captured in this plan
- **Status**: COMPLIANT - Documentation approach defined

### VI. Incremental Implementation ✅ PASS
- **Requirement**: Implementation tasks limited to 4-6 files per batch
- **Compliance**:
  - Feature decomposed into 6 prioritized user stories
  - Each story can be implemented incrementally
  - Batch 1: Core infrastructure + View (P1)
  - Batch 2: Add/Remove (P2-P3)
  - Batch 3: Modify + Extension depth (P4-P5)
  - Batch 4: Batch operations (P6)
- **Status**: COMPLIANT - Incremental implementation strategy defined

**Overall Gate Status**: ✅ ALL GATES PASS

**Post-Design Re-evaluation**: ✅ CONFIRMED - All principles maintained after Phase 0 Research and Phase 1 Design
- research.md: All 9 technical decisions comply with constitution principles
- data-model.md: Domain model design includes comprehensive validation and error handling
- contracts/configuration-schema.json: JSON Schema ensures data integrity and validation
- contracts/cli-contract.md: CLI design follows clear interface principles with comprehensive help
- quickstart.md: User documentation provides clear guidance and best practices

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
WindowsSearchConfigurator/
├── src/
│   ├── WindowsSearchConfigurator/
│   │   ├── Program.cs                      # Entry point, DI container setup
│   │   ├── Commands/                       # CLI command handlers
│   │   │   ├── ListCommand.cs             # View/list index rules
│   │   │   ├── AddCommand.cs              # Add new index rules
│   │   │   ├── RemoveCommand.cs           # Remove index rules
│   │   │   ├── ModifyCommand.cs           # Modify existing rules
│   │   │   ├── ExportCommand.cs           # Export to JSON
│   │   │   ├── ImportCommand.cs           # Import from JSON
│   │   │   ├── SearchExtensionsCommand.cs # Search file extensions
│   │   │   └── ConfigureDepthCommand.cs   # Configure indexing depth
│   │   ├── Core/                          # Domain models and interfaces
│   │   │   ├── Models/
│   │   │   │   ├── IndexRule.cs
│   │   │   │   ├── FileTypeFilter.cs
│   │   │   │   ├── IndexLocation.cs
│   │   │   │   ├── FileExtensionSetting.cs
│   │   │   │   └── IndexingDepth.cs       # Enum: PropertiesOnly, PropertiesAndContents
│   │   │   └── Interfaces/
│   │   │       ├── ISearchIndexManager.cs
│   │   │       ├── IConfigurationStore.cs
│   │   │       ├── IAuditLogger.cs
│   │   │       └── IPrivilegeChecker.cs
│   │   ├── Services/                      # Business logic implementations
│   │   │   ├── SearchIndexManager.cs      # Windows Search API integration
│   │   │   ├── ConfigurationStore.cs      # JSON import/export
│   │   │   ├── AuditLogger.cs            # Text file logging
│   │   │   ├── PrivilegeChecker.cs       # Admin privilege verification
│   │   │   └── PathValidator.cs          # Path validation logic
│   │   ├── Infrastructure/                # Windows API wrappers
│   │   │   ├── WindowsSearchInterop.cs   # COM/WMI/Registry wrapper
│   │   │   ├── RegistryAccessor.cs       # Registry operations
│   │   │   └── ServiceStatusChecker.cs   # Windows Search service status
│   │   └── Utilities/                     # Helper functions
│   │       ├── WildcardMatcher.cs        # Wildcard pattern matching
│   │       ├── PathNormalizer.cs         # Path handling (UNC, relative, absolute)
│   │       └── ConsoleFormatter.cs       # CLI output formatting
│   └── WindowsSearchConfigurator.csproj
│
├── tests/
│   ├── WindowsSearchConfigurator.UnitTests/
│   │   ├── Commands/                      # Command handler unit tests
│   │   ├── Services/                      # Service layer unit tests
│   │   ├── Utilities/                     # Utility function tests
│   │   └── WindowsSearchConfigurator.UnitTests.csproj
│   ├── WindowsSearchConfigurator.IntegrationTests/
│   │   ├── SearchIndexManagerTests.cs     # Real Windows Search API tests
│   │   ├── ConfigurationStoreTests.cs     # JSON file I/O tests
│   │   ├── EndToEndTests.cs              # Full workflow tests
│   │   └── WindowsSearchConfigurator.IntegrationTests.csproj
│   └── WindowsSearchConfigurator.ContractTests/
│       ├── CommandContractTests.cs        # CLI interface contract tests
│       └── WindowsSearchConfigurator.ContractTests.csproj
│
├── docs/
│   └── README.md                          # User documentation
│
└── WindowsSearchConfigurator.sln          # Solution file
```

**Structure Decision**: Single console application project using standard .NET solution structure. The application follows clean architecture principles with separation of concerns:
- **Commands/**: CLI layer handling user input/output
- **Core/**: Domain models and interfaces (technology-agnostic)
- **Services/**: Business logic and orchestration
- **Infrastructure/**: Windows API integration (platform-specific)
- **Utilities/**: Cross-cutting helper functions

This structure supports testability (dependency injection, interface-based design), maintainability (clear separation of concerns), and incremental implementation (each layer can be built independently).

## Complexity Tracking

> No constitution violations identified. All principles compliant.
